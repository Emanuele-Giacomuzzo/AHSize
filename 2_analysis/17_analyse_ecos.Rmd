---
title: "Untitled"
output: html_document
date: "2023-11-28"
editor_options: 
  chunk_output_type: console
---

In our experiment, we manipulated meta-ecosystems consisting of autotrophic and heterotrophic patches, varying the relative size of these patches (referred to as meta-ecosystem types AD, ED, and HD) and their connectivity (unconnected versus connected). Now, we want to know whether, at the local ecosystem level, the connectivity of the ecosystem interacted with ecosystem size to affect this specific response variable. Essentially, we are interested in understanding if ecosystem size modulated the impact of spatial feedback locally. To begin, we plot how this response variable varied across different treatments throughout the experiment, represented by mean values with a 95% confidence interval.

```{r}
plot.ecosystems.points(ds_ecosystems %>% 
                         filter(trophic_type == trophy_selected),
                       response_variable,
                       legend_row_n_input = 3)
```

<details>

<summary>To view how the means of each treatment were calculated from the single replicates, click here.</summary>

```{r}
plot.ecosystems.replicates.one.by.one(ds_ecosystems,
                                      ecosystem_size_and_trophy_selected,
                                      response_variable)
```

</details>

 <br>

Following this initial inspection, we proceed to analyse differences among ecosystems. Our first step involves filtering the data to isolate the relevant data for analysis. Specifically, we exclude data points where the response variable couldn't be computed, as well as time points preceding the initial disturbance and resource flow. Then we plot the data to make sure that what filtered the data in the right way.

```{r}
filtered_data = ds_ecosystems %>%
  filter(trophic_type == trophy_selected,
         time_point %in% time_points_model,
         !is.na(!!sym(response_variable))) %>%
  mutate(ecosystem_ID = as.character(ecosystem_ID),
         size = NA,
         size = case_when(ecosystem_size == "Small" ~ "S",
                          ecosystem_size == "Medium" ~ "M",
                          ecosystem_size == "Large" ~ "L",
                          TRUE ~ size),
         size = factor(size, levels = c("S", "M", "L")),
         size = as.character(size))
```

```{r}
plot.ecosystems.points(filtered_data,
                       response_variable,
                       legend_row_n_input = 3)
```

<details>

<summary>To view how treatment means arose from the single replicates, click here.</summary>

```{r}
plot.ecosystems.replicates.one.by.one(filtered_data,
                                      ecosystem_size_and_trophy_selected,
                                      response_variable)
```
</details>

<br>

```{r eval = (response_variable %in% c("species_richness", "shannon", "evenness_pielou"))}

## - Create mixed effect model - ##
# In the ouput lmerModLmerTest which means that it's a Linear Mixed Model from the lmerTest package

if((response_variable %in% c("bioarea_mm2_per_ml", "indiv_per_ml", "median_body_size_µm2")) == FALSE){
  
 model = lmer(get(response_variable) ~
               size * connection +
               (1 | ecosystem_ID) +
               (1 | day),
             data = filtered_data,
             REML = FALSE,
             control = lmerControl(optimizer = "Nelder_Mead"))
 
}
```

```{r eval = (response_variable %in% c("bioarea_mm2_per_ml", "indiv_per_ml", "median_body_size_µm2"))}

## - Create mixed effect model - ##

model <- glmmTMB::glmmTMB(get(response_variable) ~
                            size * connection +
                            (1 | ecosystem_ID) +
                            (1 | day),
                          data = filtered_data,
                          family = glmmTMB::tweedie(link = "log"))
```

```{r}

## - Show summary of the model -- ##

print(summary(model), digits = 3)
```

```{r}

## - Plot residuals of the model -- ##

qqnorm(resid(model))
qqline(resid(model))

create.res.vs.fit.ecosystems(model,
                             filtered_data)
```

```{r}

## - Perform Type III ANOVA on the model - ##

car::Anova(model, type = "III")
```

```{r}

## - Analyse the contrasts among levels -- ##

emmeans_output = emmeans(model,
                         specs = pairwise ~ size:connection,
                         adjust = "tukey",
                         bias.adj = TRUE,
                         lmer.df = "satterthwaite")
```

<details>
<summary>Show how the contrasts were coded</summary>
```{r class.source = 'fold-show'}
emmeans_output

L_unconnected = c(1, 0, 0, 0, 0, 0)
M_unconnected = c(0, 1, 0, 0, 0, 0)
S_unconnected = c(0, 0, 1, 0, 0, 0)
L_connected = c(0, 0, 0, 1, 0, 0)
M_connected = c(0, 0, 0, 0, 1, 0)
S_connected = c(0, 0, 0, 0, 0, 1)
```
</details>

```{r eval = (response_variable %in% c("species_richness", "shannon", "evenness_pielou"))}

## - Show only the contrasts you are interested in -- ##

n_of_digits = 3
contrasts = contrast(emmeans_output, 
         method = list("Small connection effect" = S_connected - S_unconnected,
                       "Medium connection effect" = M_connected - M_unconnected,
                       "Large connection effect" = L_connected - L_unconnected,
                       "Size effect in unconnected (L - S)" = L_unconnected - S_unconnected,
                       "Size effect in unconnected (M - S)" = M_unconnected - S_unconnected,
                       "Size effect in connected (L - S)" = L_connected - S_connected,
                       "Size effect in connected (M - S)" = M_connected - S_connected)) %>%
  as.data.frame() %>%
  mutate(p.value = round(p.value, digits = n_of_digits),
         estimate = round(estimate, digits = n_of_digits),
         SE = round(SE, digits = n_of_digits),
         df = round(df, digits = n_of_digits),
         t.ratio = round(t.ratio, digits = n_of_digits),
         e = "",
         e = ifelse(p.value > 0.1, 
                           "",
                           e),
         e = ifelse(p.value < 0.05, 
                           "*",
                           e),
         e = ifelse(p.value < 0.01, 
                           "**",
                           e),
         e = ifelse(p.value < 0.001, 
                           "***",
                           e)) %>%
  rename(" " = e)

contrasts
```

```{r eval = (response_variable %in% c("bioarea_mm2_per_ml", "indiv_per_ml", "median_body_size_µm2"))}

## - Show only the contrasts you are interested in -- ##

n_of_digits = 3
contrasts = contrast(emmeans_output, 
         method = list("Small connection effect" = S_connected - S_unconnected,
                       "Medium connection effect" = M_connected - M_unconnected,
                       "Large connection effect" = L_connected - L_unconnected,
                       "Size effect in unconnected (L - S)" = L_unconnected - S_unconnected,
                       "Size effect in unconnected (M - S)" = M_unconnected - S_unconnected,
                       "Size effect in connected (L - S)" = L_connected - S_connected,
                       "Size effect in connected (M - S)" = M_connected - S_connected)) %>%
  as.data.frame() %>%
  mutate(p.value = round(p.value, digits = n_of_digits),
         estimate = round(estimate, digits = n_of_digits),
         SE = round(SE, digits = n_of_digits),
         df = round(df, digits = n_of_digits),
         z.ratio = round(z.ratio, digits = n_of_digits),
         e = "",
         e = ifelse(p.value > 0.1, 
                           "",
                           e),
         e = ifelse(p.value < 0.05, 
                           "*",
                           e),
         e = ifelse(p.value < 0.01, 
                           "**",
                           e),
         e = ifelse(p.value < 0.001, 
                           "***",
                           e)) %>%
  rename(" " = e)

contrasts
```